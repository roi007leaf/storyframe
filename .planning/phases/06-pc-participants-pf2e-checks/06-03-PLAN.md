---
phase: 06-pc-participants-pf2e-checks
plan: 03
type: execute
wave: 3
depends_on: ["06-01", "06-02"]
files_modified:
  - scripts/applications/player-viewer.mjs
  - templates/player-viewer.hbs
  - styles/player-viewer.css
autonomous: true

must_haves:
  truths:
    - "Player sees roll prompt in StoryFrame viewer when GM requests check"
    - "Roll prompt shows skill name only (no DC, no context hints)"
    - "Player can click Roll button to trigger native PF2e skill roll"
    - "PF2e roll dialog appears with modifier options"
    - "Roll result creates chat card and updates StoryFrame state"
    - "Completed roll prompt disappears from viewer"
  artifacts:
    - path: "scripts/applications/player-viewer.mjs"
      provides: "Roll prompt rendering and PF2e roll execution"
      contains: "executeRoll"
    - path: "templates/player-viewer.hbs"
      provides: "Roll prompt HTML structure"
      contains: "roll-prompt"
    - path: "styles/player-viewer.css"
      provides: "Roll prompt styling"
      contains: ".roll-prompt"
  key_links:
    - from: "scripts/applications/player-viewer.mjs"
      to: "actor.skills[slug].roll()"
      via: "PF2e native roll method"
      pattern: "actor\\.skills\\[.*\\]\\.roll"
    - from: "scripts/applications/player-viewer.mjs"
      to: "scripts/socket-manager.mjs"
      via: "submitRollResult socket call"
      pattern: "socketManager\\.requestSubmitRollResult"
---

<objective>
Add roll prompt display and PF2e roll execution to player viewer.

Purpose: Players receive check requests in their viewer and execute native PF2e rolls
Output: Roll prompts appear in viewer, clicking Roll triggers PF2e dialog, results sync back
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-pc-participants-pf2e-checks/06-CONTEXT.md
@.planning/phases/06-pc-participants-pf2e-checks/06-RESEARCH.md
@.planning/phases/06-pc-participants-pf2e-checks/06-01-SUMMARY.md
@.planning/phases/06-pc-participants-pf2e-checks/06-02-SUMMARY.md
@scripts/applications/player-viewer.mjs
@templates/player-viewer.hbs
@styles/player-viewer.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add roll prompt template section to player viewer</name>
  <files>templates/player-viewer.hbs</files>
  <action>
Add roll prompt section to player-viewer.hbs that displays pending skill check requests:

1. Add roll prompts section at the top of the viewer (above speaker gallery):
   ```handlebars
   {{#if pendingRolls.length}}
   <div class="roll-prompts">
     {{#each pendingRolls}}
       <div class="roll-prompt" data-request-id="{{this.id}}">
         <div class="prompt-content">
           <span class="skill-name">{{this.skillName}}</span>
           <span class="prompt-text">Check Requested</span>
         </div>
         <button type="button"
                 class="roll-btn"
                 data-action="executeRoll"
                 data-request-id="{{this.id}}">
           <i class="fas fa-dice-d20"></i> Roll
         </button>
       </div>
     {{/each}}
   </div>
   {{/if}}
   ```

2. The prompt should be visually prominent but not blocking the speaker gallery.
   It appears above the gallery when there are pending rolls for this player.

3. Only show prompts relevant to this player's participant:
   - Context prep filters pendingRolls by participantId matching current user's participant
  </action>
  <verify>
- Template compiles without errors
- When pendingRolls context has entries, roll prompts render
- Roll button has data-action and data-request-id attributes
  </verify>
  <done>Player viewer template includes roll prompt section</done>
</task>

<task type="auto">
  <name>Task 2: Add roll prompt logic and PF2e roll execution to PlayerViewerApp</name>
  <files>scripts/applications/player-viewer.mjs</files>
  <action>
Add roll prompt handling and PF2e skill roll execution to PlayerViewerApp:

1. Add to DEFAULT_OPTIONS.actions:
   - executeRoll: PlayerViewerApp._onExecuteRoll

2. Update _prepareContext to include pending rolls for this player:
   ```javascript
   async _prepareContext(options) {
     const state = game.storyframe.stateManager.getState();
     const layout = game.settings.get(MODULE_ID, 'playerViewerLayout') || 'grid';

     // Find this player's participant
     const myParticipant = (state.participants || []).find(p => p.userId === game.user.id);

     // Get pending rolls for this player
     let pendingRolls = [];
     if (myParticipant) {
       pendingRolls = (state.pendingRolls || [])
         .filter(r => r.participantId === myParticipant.id)
         .map(r => ({
           ...r,
           skillName: this._getSkillDisplayName(r.skillSlug)
         }));
     }

     // ... existing speaker logic ...

     return {
       speakers,
       activeSpeakerId: state.activeSpeaker,
       layout,
       empty: !state?.speakers || state.speakers.length === 0,
       pendingRolls,
       hasPrompts: pendingRolls.length > 0
     };
   }
   ```

3. Add _getSkillDisplayName(slug) helper method:
   ```javascript
   _getSkillDisplayName(slug) {
     const skillNames = {
       per: 'Perception',
       acr: 'Acrobatics',
       arc: 'Arcana',
       ath: 'Athletics',
       cra: 'Crafting',
       dec: 'Deception',
       dip: 'Diplomacy',
       itm: 'Intimidation',
       med: 'Medicine',
       nat: 'Nature',
       occ: 'Occultism',
       prf: 'Performance',
       rel: 'Religion',
       soc: 'Society',
       ste: 'Stealth',
       sur: 'Survival',
       thi: 'Thievery'
     };
     return skillNames[slug] || slug;
   }
   ```

4. Implement _onExecuteRoll action handler:
   ```javascript
   static async _onExecuteRoll(event, target) {
     const requestId = target.dataset.requestId;
     if (!requestId) return;

     const state = game.storyframe.stateManager.getState();
     const request = state.pendingRolls?.find(r => r.id === requestId);
     if (!request) {
       ui.notifications.warn('Roll request not found');
       return;
     }

     const participant = state.participants?.find(p => p.id === request.participantId);
     if (!participant) {
       ui.notifications.error('Participant not found');
       return;
     }

     const actor = await fromUuid(participant.actorUuid);
     if (!actor) {
       ui.notifications.error('Actor not found');
       return;
     }

     // Execute the PF2e roll
     let rollResult;
     try {
       if (request.skillSlug === 'per') {
         // Perception check (separate from skills in PF2e)
         rollResult = await actor.perception.roll({
           dc: request.dc,
           skipDialog: false // Show PF2e modifier dialog
         });
       } else {
         // Skill check
         const skill = actor.skills?.[request.skillSlug];
         if (!skill) {
           ui.notifications.error(`Skill "${request.skillSlug}" not found on actor`);
           return;
         }
         rollResult = await skill.roll({
           dc: request.dc,
           skipDialog: false
         });
       }
     } catch (err) {
       console.error('StoryFrame | Roll execution error:', err);
       ui.notifications.error('Failed to execute roll');
       return;
     }

     // If roll was cancelled (user closed dialog), don't submit
     if (!rollResult) return;

     // Extract result data
     const result = {
       requestId,
       participantId: request.participantId,
       skillSlug: request.skillSlug,
       total: rollResult.total ?? rollResult.roll?.total ?? 0,
       degreeOfSuccess: rollResult.degreeOfSuccess?.value ?? 0,
       timestamp: Date.now(),
       chatMessageId: rollResult.message?.id || null
     };

     // Submit result via socket (this removes pending roll and adds to history)
     await game.storyframe.socketManager.requestSubmitRollResult(result);

     ui.notifications.info(`${this._getSkillDisplayName(request.skillSlug)} check complete`);
   }
   ```

5. Add method to refresh view when socket notifies of roll prompt:
   ```javascript
   showRollPrompt(requestData) {
     // Socket handler calls this when player receives roll request
     // Just re-render to pick up new pending roll from state
     this.render();
   }
   ```

6. Make _getSkillDisplayName a static method so it can be called from static action handler,
   OR bind it to the instance in constructor. Simplest: make it static.
  </action>
  <verify>
Testing requires a GM and player client:
1. GM adds player's PC as participant
2. GM requests Diplomacy check
3. Player viewer re-renders with roll prompt visible
4. Player clicks Roll - PF2e dialog appears
5. Player completes roll - chat card created, prompt disappears
6. State shows roll in rollHistory
  </verify>
  <done>PlayerViewerApp displays roll prompts and executes native PF2e rolls</done>
</task>

<task type="auto">
  <name>Task 3: Style roll prompts in player viewer</name>
  <files>styles/player-viewer.css</files>
  <action>
Add CSS for roll prompts that are noticeable but not overwhelming:

1. Roll prompts container:
   ```css
   .roll-prompts {
     display: flex;
     flex-direction: column;
     gap: 0.5rem;
     padding: 0.5rem;
     background: var(--color-bg-warning, #fff3cd);
     border-bottom: 2px solid var(--color-warning, #ffc107);
   }
   ```

2. Individual roll prompt:
   ```css
   .roll-prompt {
     display: flex;
     justify-content: space-between;
     align-items: center;
     padding: 0.75rem;
     background: white;
     border-radius: 6px;
     box-shadow: 0 2px 4px rgba(0,0,0,0.1);
     animation: pulse-border 2s infinite;
   }

   @keyframes pulse-border {
     0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
     50% { box-shadow: 0 2px 8px rgba(0,0,0,0.2), 0 0 0 2px var(--color-primary, #5e81ac); }
   }

   .roll-prompt .prompt-content {
     display: flex;
     flex-direction: column;
   }

   .roll-prompt .skill-name {
     font-weight: bold;
     font-size: 1.1rem;
     color: var(--color-text-dark, #333);
   }

   .roll-prompt .prompt-text {
     font-size: 0.85rem;
     color: var(--color-text-muted, #666);
   }
   ```

3. Roll button styling:
   ```css
   .roll-prompt .roll-btn {
     display: flex;
     align-items: center;
     gap: 0.5rem;
     padding: 0.5rem 1rem;
     background: var(--color-primary, #5e81ac);
     color: white;
     border: none;
     border-radius: 6px;
     font-size: 1rem;
     font-weight: bold;
     cursor: pointer;
     transition: background 0.15s, transform 0.1s;
   }

   .roll-prompt .roll-btn:hover {
     background: var(--color-primary-dark, #4c669f);
     transform: scale(1.02);
   }

   .roll-prompt .roll-btn:active {
     transform: scale(0.98);
   }

   .roll-prompt .roll-btn i {
     font-size: 1.2rem;
   }
   ```

4. Ensure roll prompts don't break speaker gallery layout:
   ```css
   .player-viewer .speaker-gallery {
     flex: 1;
     overflow-y: auto;
   }

   /* When prompts exist, gallery should still scroll independently */
   .player-viewer {
     display: flex;
     flex-direction: column;
     height: 100%;
   }
   ```
  </action>
  <verify>
- Roll prompts appear with yellow/warning background
- Skill name is prominent and readable
- Roll button is large, obvious, and inviting to click
- Subtle animation draws attention without being annoying
- Speaker gallery scrolls independently of prompts
  </verify>
  <done>Roll prompts are styled to be noticeable and easy to interact with</done>
</task>

</tasks>

<verification>
1. Player viewer shows roll prompts when GM requests check
2. Prompt displays skill name (e.g., "Diplomacy") without DC
3. Clicking Roll opens PF2e modifier dialog
4. Completing roll creates chat card with proper speaker
5. Completed roll disappears from viewer
6. Roll result appears in state.rollHistory
7. Prompts don't block or overlap speaker gallery
8. Multiple pending prompts stack correctly
</verification>

<success_criteria>
- Players see roll prompts in their StoryFrame viewer
- Clicking Roll triggers native PF2e roll with modifier dialog
- Roll results sync back to state via socket
- Prompts disappear after roll completion
- UI is clear, noticeable, and responsive
</success_criteria>

<output>
After completion, create `.planning/phases/06-pc-participants-pf2e-checks/06-03-SUMMARY.md`
</output>
