---
phase: 07-premium-journal-css-scraper
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/css-scraper.mjs
autonomous: true

must_haves:
  truths:
    - "CSS scraper filters stylesheets by URL to exclude other premium modules"
    - "Selectors with body, html, :root are preserved without namespacing"
    - "Premium module keywords filter CSS content accurately"
  artifacts:
    - path: "scripts/css-scraper.mjs"
      provides: "Hybrid CSS filtering and selective namespacing"
      exports: ["CSSScraper"]
      contains: "shouldNamespace"
  key_links:
    - from: "scripts/css-scraper.mjs"
      to: "document.styleSheets"
      via: "CSSOM iteration with CORS handling"
      pattern: "sheet\\.cssRules"
---

<objective>
Refactor CSS scraper with hybrid filtering (URL + keyword) and selective namespacing that preserves complex selectors.

Purpose: Current implementation extracts too much CSS (200KB payloads) and breaks complex selectors like `body.game .app .pf2e-km`. This plan fixes both issues at the core scraper level.

Output: Refactored CSSScraper class with accurate filtering and DOM-aware namespacing.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-premium-journal-css-scraper/07-RESEARCH.md
@.planning/phases/07-premium-journal-css-scraper/07-CONTEXT.md
@scripts/css-scraper.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement hybrid CSS filtering</name>
  <files>scripts/css-scraper.mjs</files>
  <action>
Refactor `extractJournalCSS()` method with hybrid filtering approach:

1. **URL-based filtering** (when `sheet.href` available):
   - Build exclusion list from known premium modules: kingmaker, beginner-box, abomination-vaults, outlaws, bloodlords, gatewalkers, stolenfate, skyking, seasonofghosts, wardensofwildwood, curtaincall, triumphofthetusk, sporewar, pfs (pathfinder society)
   - Skip stylesheets that match other modules when we know the target module
   - Allow stylesheets that match the target module OR are generic (pf2e, system, foundry)

2. **Keyword-based filtering** (for each CSS rule):
   - Primary keywords: the extracted class itself (e.g., 'pf2e-km', 'pf2e-pfs07')
   - Secondary keywords: journal, page-content, entry-page, text-content
   - Include rule only if it matches primary OR secondary keywords
   - For world journals (pack is null): use extractedClass as the filter keyword

3. **Handle world journals gracefully**:
   - When `journal.pack` is null, rely on `extractedClass` parameter for filtering
   - If extractedClass is provided, use it as primary filter keyword
   - Extract module name from class (e.g., 'km' from 'pf2e-km') for URL filtering

4. **CORS handling**:
   - Wrap `cssRules` access in try-catch
   - Skip stylesheets with SecurityError (external/cross-origin)
   - Log debug message for skipped stylesheets

Update method signature: `extractJournalCSS(journal, extractedClass = null)` (already exists, just ensure it's used properly).
  </action>
  <verify>
Read the file and verify:
- URL filtering logic checks `sheet.href` against exclusion list
- Keyword filtering checks `rule.cssText` against primary and secondary keywords
- CORS errors are caught with SecurityError check
- extractedClass parameter is used for world journal filtering
  </verify>
  <done>
CSS extraction filters by URL pattern first (excluding other premium modules), then by keywords (including only relevant rules). World journals without pack use extractedClass for filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement selective namespacing</name>
  <files>scripts/css-scraper.mjs</files>
  <action>
Refactor `namespaceCSSRules()` method with selective namespacing:

1. **Add `shouldNamespace(selector)` helper function**:
   ```javascript
   function shouldNamespace(selector) {
     // Don't namespace selectors with DOM-contextual elements
     const contextual = ['body', 'html', ':root'];
     if (contextual.some(ctx => selector.toLowerCase().includes(ctx))) return false;

     // Don't namespace already-scoped selectors
     if (selector.includes('.journal-page-content')) return false;
     if (selector.includes('.journal-entry')) return false;

     // Namespace everything else
     return true;
   }
   ```

2. **Update `namespaceCSSRules()` to use selective logic**:
   - For each selector in a rule, check `shouldNamespace()`
   - If false, preserve original selector unchanged
   - If true, prefix with namespace
   - Handle @-rules (@media, @layer, @keyframes) by recursing into their contents OR preserving them as-is

3. **Preserve @layer directives**:
   - @layer blocks should be preserved without modification
   - Don't attempt to namespace inside @layer (complex cascade implications)
   - @media blocks: recurse into rules inside
   - @keyframes: preserve entirely

4. **Handle multi-selector rules correctly**:
   - Split on comma, apply shouldNamespace to each
   - Some selectors may be namespaced, others not, in same rule
   - Rejoin with comma
  </action>
  <verify>
Read the file and verify:
- `shouldNamespace()` function exists and checks for body, html, :root
- `namespaceCSSRules()` calls `shouldNamespace()` for each selector
- @-rules (@layer, @media, @keyframes) are handled specially
- Multi-selector rules are split and processed individually
  </verify>
  <done>
Selectors containing body, html, :root, .journal-page-content, or .journal-entry are preserved unchanged. All other selectors are namespaced. @layer directives preserved entirely.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. CSSScraper.extractJournalCSS filters by URL (excludes other modules) and keywords
2. CSSScraper.namespaceCSSRules preserves complex selectors with DOM-contextual elements
3. No syntax errors in the module (check with `node --check scripts/css-scraper.mjs` if available, or visual inspection)
</verification>

<success_criteria>
- extractJournalCSS returns filtered CSS (not 200KB payloads)
- namespaceCSSRules preserves `body.game .app` style selectors
- Code handles CORS errors gracefully
- @layer directives not broken
</success_criteria>

<output>
After completion, create `.planning/phases/07-premium-journal-css-scraper/07-01-SUMMARY.md`
</output>
