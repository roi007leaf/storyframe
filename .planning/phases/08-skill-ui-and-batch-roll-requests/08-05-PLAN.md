---
phase: 08-skill-ui-batch-rolls
plan: 05
type: execute
wave: 2
depends_on: ["08-02", "08-04"]
files_modified:
  - scripts/applications/gm-sidebar.mjs
  - scripts/applications/gm-sidebar-pf2e.mjs
  - templates/gm-sidebar.hbs
autonomous: true

must_haves:
  truths:
    - "GM can select multiple skills for batch roll request (one atomic request, not persistent challenge)"
    - "Each player prompted only with skills they possess"
    - "Per-skill proficiency filter validation filters participants by their proficiency rank"
  artifacts:
    - path: "scripts/applications/gm-sidebar.mjs"
      provides: "Batch roll request handler"
      contains: "_onBatchRollRequest"
    - path: "scripts/applications/gm-sidebar-pf2e.mjs"
      provides: "Proficiency rank lookup"
      contains: "_getSkillRank"
  key_links:
    - from: "gm-sidebar.mjs"
      to: "state-manager.mjs"
      via: "addPendingRolls for batch"
      pattern: "addPendingRolls"
    - from: "gm-sidebar.mjs"
      to: "socket-manager.mjs"
      via: "sendRollRequest for each participant"
      pattern: "sendRollRequest"
---

<objective>
Implement batch roll request functionality that sends skill check requests to multiple participants for multiple skills in one atomic operation.

Purpose: Allow GM to select multiple skills and request rolls from all selected participants in one action, with per-skill proficiency filtering ensuring each player only receives requests for skills they possess and meet the proficiency requirement.

Output: Batch roll request handler that validates participant skills and proficiency, creates pending roll entries atomically, and sends socket notifications to players.
</objective>

<execution_context>
@C:\Users\User\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\User\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-skill-ui-and-batch-roll-requests/08-CONTEXT.md
@.planning/phases/08-skill-ui-and-batch-roll-requests/08-RESEARCH.md
@.planning/phases/08-skill-ui-and-batch-roll-requests/08-02-SUMMARY.md
@.planning/phases/08-skill-ui-and-batch-roll-requests/08-04-SUMMARY.md
@scripts/applications/gm-sidebar.mjs
@scripts/applications/gm-sidebar-pf2e.mjs
@scripts/state-manager.mjs
@scripts/socket-manager.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Proficiency Rank Lookup Method</name>
  <files>scripts/applications/gm-sidebar-pf2e.mjs</files>
  <action>
Add method to GMSidebarAppPF2e to get skill proficiency rank:

1. Add static method for proficiency rank lookup:
```javascript
/**
 * Get skill proficiency rank for an actor (PF2e specific)
 * @param {string} actorUuid - The actor UUID
 * @param {string} skillSlug - The skill slug (short form like 'ste' or full like 'stealth')
 * @returns {Promise<number>} Proficiency rank (0=Untrained, 1=Trained, 2=Expert, 3=Master, 4=Legendary)
 */
static async _getSkillRank(actorUuid, skillSlug) {
  const actor = await fromUuid(actorUuid);
  if (!actor?.system?.skills) return 0;

  // Map short skill slugs to full PF2e skill slugs
  const PF2E_SKILL_SLUG_MAP = {
    per: 'perception',
    acr: 'acrobatics',
    arc: 'arcana',
    ath: 'athletics',
    cra: 'crafting',
    dec: 'deception',
    dip: 'diplomacy',
    itm: 'intimidation',
    med: 'medicine',
    nat: 'nature',
    occ: 'occultism',
    prf: 'performance',
    rel: 'religion',
    soc: 'society',
    ste: 'stealth',
    sur: 'survival',
    thi: 'thievery',
  };

  // Map short slug to full slug
  const fullSlug = PF2E_SKILL_SLUG_MAP[skillSlug] || skillSlug;

  // Handle perception specially (uses actor.perception not actor.skills)
  if (fullSlug === 'perception') {
    return actor.perception?.rank ?? 0;
  }

  // Check standard skills
  const skill = actor.system.skills[fullSlug];
  if (skill) {
    return skill.rank ?? 0;
  }

  // Check if it's a lore skill (already in "politics-lore" format)
  if (skillSlug.includes('-lore')) {
    const loreSkill = actor.system.skills[skillSlug];
    return loreSkill?.rank ?? 0;
  }

  return 0; // Untrained/unknown
}
```

2. Note: This method is system-specific. The base class in gm-sidebar.mjs should have a default implementation that returns 0 (no proficiency check for non-PF2e systems).

3. Add default implementation in GMSidebarAppBase:
```javascript
/**
 * Get skill proficiency rank for an actor (base implementation)
 * Override in system-specific subclasses
 * @param {string} actorUuid - The actor UUID
 * @param {string} skillSlug - The skill slug
 * @returns {Promise<number>} Proficiency rank (default: 0 = no check)
 */
static async _getSkillRank(_actorUuid, _skillSlug) {
  return 0; // No proficiency checking in base implementation
}
```
  </action>
  <verify>
In console: Test `GMSidebarAppPF2e._getSkillRank(actorUuid, 'ste')` for a PC with different stealth proficiency levels. Verify correct rank returned (0-4).
  </verify>
  <done>
Proficiency rank lookup implemented for PF2e. Handles both short slugs (ste) and full slugs (stealth). Special handling for perception. Lore skills supported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Batch Roll Request Handler</name>
  <files>scripts/applications/gm-sidebar.mjs</files>
  <action>
Add batch roll request handler to GMSidebarAppBase:

1. Add action in DEFAULT_OPTIONS.actions:
```javascript
batchRollRequest: GMSidebarAppBase._onBatchRollRequest,
```

2. Implement the batch roll request handler:
```javascript
/**
 * Handle batch roll request for multiple selected skills
 * Creates individual pending rolls for each participant-skill combination
 * where participant has the skill and meets proficiency requirement
 */
static async _onBatchRollRequest() {
  // Validate selections
  if (this.selectedSkills.size === 0) {
    ui.notifications.warn('No skills selected');
    return;
  }

  if (this.selectedParticipants.size === 0) {
    ui.notifications.warn('No participants selected');
    return;
  }

  const state = game.storyframe.stateManager.getState();
  if (!state) return;

  // Get DC and secret roll settings
  const dcInput = this.element.querySelector('#dc-input');
  const dc = dcInput?.value ? parseInt(dcInput.value) : null;
  const secretCheckbox = this.element.querySelector('#secret-roll-checkbox');
  const isSecret = secretCheckbox?.checked || false;

  if (!dc) {
    ui.notifications.warn('Set a DC before requesting rolls');
    return;
  }

  // Build list of pending roll requests
  const requests = [];
  let skippedProficiency = 0;
  let skippedMissingSkill = 0;

  for (const skillSlug of this.selectedSkills) {
    const proficiencyFilter = this.skillProficiencyFilters.get(skillSlug) || 0;

    for (const participantId of this.selectedParticipants) {
      const participant = state.participants.find(p => p.id === participantId);
      if (!participant) continue;

      // Check if participant has this skill
      const actor = await fromUuid(participant.actorUuid);
      if (!actor) continue;

      const hasSkill = await this._actorHasSkill(actor, skillSlug);
      if (!hasSkill) {
        skippedMissingSkill++;
        continue;
      }

      // Check proficiency requirement if set
      if (proficiencyFilter > 0) {
        const skillRank = await this.constructor._getSkillRank(participant.actorUuid, skillSlug);
        if (skillRank < proficiencyFilter) {
          skippedProficiency++;
          continue;
        }
      }

      // Create pending roll request
      requests.push({
        id: foundry.utils.randomID(),
        participantId,
        skillSlug,
        actionSlug: null,
        dc,
        isSecret,
        timestamp: Date.now()
      });
    }
  }

  // Validate we have requests to send
  if (requests.length === 0) {
    let msg = 'No valid roll requests generated.';
    if (skippedMissingSkill > 0) msg += ` (${skippedMissingSkill} skipped - skill not possessed)`;
    if (skippedProficiency > 0) msg += ` (${skippedProficiency} skipped - insufficient proficiency)`;
    ui.notifications.warn(msg);
    return;
  }

  // Add all pending rolls to state atomically
  // Use existing addPendingRoll method in a loop, or batch if supported
  for (const request of requests) {
    await game.storyframe.stateManager.addPendingRoll(request);
  }

  // Send socket notifications to players
  for (const request of requests) {
    const participant = state.participants.find(p => p.id === request.participantId);
    if (participant?.userId) {
      await game.storyframe.socketManager.promptSkillCheck({
        participantId: request.participantId,
        skillSlug: request.skillSlug,
        actionSlug: request.actionSlug,
        dc: request.dc,
        isSecret: request.isSecret,
        requestId: request.id
      });
    }
  }

  // Show summary notification
  let summary = `Sent ${requests.length} roll request(s)`;
  if (skippedProficiency > 0) summary += ` (${skippedProficiency} skipped for proficiency)`;
  ui.notifications.info(summary);

  // Clear selection after sending
  this._clearSkillSelection();
  this.render();
}
```

3. Note on atomicity: The "atomic" requirement from CONTEXT.md means the GM clicks once and all requests are sent together. It doesn't require database atomicity. The loop above handles this - one user action creates multiple pending rolls.

4. If StateManager has a batch method (`addPendingRolls`), use it instead of looping:
```javascript
// Batch add if method exists
if (typeof game.storyframe.stateManager.addPendingRolls === 'function') {
  await game.storyframe.stateManager.addPendingRolls(requests);
} else {
  // Fallback to individual adds
  for (const request of requests) {
    await game.storyframe.stateManager.addPendingRoll(request);
  }
}
```
  </action>
  <verify>
In FoundryVTT: Select 2 PCs, select 3 skills (some with proficiency filters). Click "Request Roll(s)". Verify notification shows correct counts. Verify pending rolls appear in state. Verify players receive prompts only for skills they have and meet proficiency for.
  </verify>
  <done>
Batch roll request handler creates pending rolls for each valid participant-skill combination. Validates skill possession and proficiency requirements. Shows summary with skip counts. Clears selection after sending.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Batch Request Button to Template</name>
  <files>templates/gm-sidebar.hbs</files>
  <action>
Update the batch request bar in gm-sidebar.hbs to include the "Request Roll(s)" button:

1. Find the batch-request-bar section (added in Plan 02, Task 3).

2. Update it to include both the request button and the clear button:
```handlebars
{{#if hasSelectedSkills}}
<div class="batch-request-bar">
  <span class="selected-skill-count">{{selectedSkills.length}} skill(s) selected</span>
  <div class="batch-actions">
    <button type="button"
            class="batch-btn request"
            data-action="batchRollRequest"
            data-tooltip="Send roll requests to selected participants for all selected skills">
      <i class="fas fa-dice-d20"></i>
      Request Roll(s)
    </button>
    <button type="button"
            class="batch-btn create-challenge"
            data-action="createChallengeFromSkillSelection"
            data-tooltip="Create a persistent challenge from selected skills">
      <i class="fas fa-tasks"></i>
    </button>
    <button type="button"
            class="batch-btn clear"
            data-action="clearSkillSelection"
            data-tooltip="Clear Selection">
      <i class="fas fa-times"></i>
    </button>
  </div>
</div>
{{/if}}
```

3. Add CSS for the request button (in gm-sidebar.css):
```css
.batch-request-bar .batch-btn.request {
  background: var(--sf-accent-primary);
  color: white;
  display: flex;
  align-items: center;
  gap: 6px;
}

.batch-request-bar .batch-btn.request:hover {
  background: var(--sf-accent-primary-hover);
}

.batch-request-bar .batch-btn.create-challenge {
  background: var(--sf-bg-hover);
  color: var(--sf-text-secondary);
  border: 1px solid var(--sf-border-medium);
}

.batch-request-bar .batch-btn.create-challenge:hover {
  background: var(--sf-bg-elevated);
  border-color: var(--sf-accent-secondary);
  color: var(--sf-accent-secondary);
}
```

4. Add action handler for creating challenge from skill selection (placeholder for future implementation):
In DEFAULT_OPTIONS.actions:
```javascript
createChallengeFromSkillSelection: GMSidebarAppBase._onCreateChallengeFromSkillSelection,
```

In the class:
```javascript
static async _onCreateChallengeFromSkillSelection() {
  if (this.selectedSkills.size === 0) {
    ui.notifications.warn('No skills selected');
    return;
  }

  // Convert selected skills to challenge options
  const options = Array.from(this.selectedSkills).map(skillSlug => ({
    skillSlug,
    proficiencyFilter: this.skillProficiencyFilters.get(skillSlug) || 0
  }));

  // Open challenge builder with pre-populated options
  // This integrates with the existing ChallengeBuilderDialog
  const dialog = new ChallengeBuilderDialog({
    preselectedSkills: options,
    participants: Array.from(this.selectedParticipants)
  });
  dialog.render(true);

  // Clear selection
  this._clearSkillSelection();
  this.render();
}
```

5. Note: The challenge builder integration may require updates to ChallengeBuilderDialog to accept `preselectedSkills`. This is optional enhancement - the batch roll request is the primary feature.
  </action>
  <verify>
In FoundryVTT: Select PCs and skills. Verify batch request bar shows "X skill(s) selected" with Request Roll(s) button, Create Challenge button, and Clear button. Click Request Roll(s) - verify rolls are sent.
  </verify>
  <done>
Batch request bar includes Request Roll(s) button and Create Challenge button. Request button triggers batch roll request. Create Challenge opens challenge builder with selected skills.
  </done>
</task>

</tasks>

<verification>
1. Open FoundryVTT with StoryFrame module
2. Add 2+ PCs as participants with different skill proficiencies
3. Select all participants
4. Shift+click to select 2-3 skills
5. Set proficiency filter on one skill (e.g., "Expert+" for Thievery)
6. Set a DC value
7. Click "Request Roll(s)" button
8. Verify notification shows sent count and any skipped rolls
9. Verify pending rolls indicator shows correct count
10. Check each player's client - verify they only receive prompts for skills they have and meet proficiency for
11. PC with Untrained Thievery should NOT receive Thievery prompt if Expert+ filter set
12. All PCs should receive prompts for skills without proficiency filters (if they have the skill)
</verification>

<success_criteria>
- Batch roll request sends multiple skill checks in one action
- Each participant only prompted for skills they possess
- Per-skill proficiency filters exclude participants below requirement
- Notification shows summary of sent/skipped requests
- Selection clears after sending batch request
- DC and secret roll settings applied to all requests
</success_criteria>

<output>
After completion, create `.planning/phases/08-skill-ui-and-batch-roll-requests/08-05-SUMMARY.md`
</output>
