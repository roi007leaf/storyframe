---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - scripts/state-manager.mjs
  - scripts/socket-manager.mjs
  - storyframe.mjs
autonomous: true

must_haves:
  truths:
    - "Speaker data persists to document flags and restores on reload"
    - "Socket communication broadcasts state changes to all clients"
    - "GM permissions validated before state mutations"
    - "Flag schema includes version number"
  artifacts:
    - path: "scripts/state-manager.mjs"
      provides: "StateManager class with flag persistence"
      exports: ["StateManager"]
      contains: "version"
    - path: "scripts/socket-manager.mjs"
      provides: "SocketManager class with socketlib integration"
      exports: ["SocketManager"]
      contains: "socketlib"
    - path: "storyframe.mjs"
      provides: "Manager initialization in hooks"
      contains: "StateManager"
  key_links:
    - from: "scripts/socket-manager.mjs"
      to: "scripts/state-manager.mjs"
      via: "socket handlers call stateManager"
      pattern: "game\\.storyframe\\.stateManager"
    - from: "scripts/state-manager.mjs"
      to: "scene.setFlag"
      via: "flag persistence"
      pattern: "setFlag.*storyframe"
    - from: "storyframe.mjs"
      to: "scripts/state-manager.mjs"
      via: "import and instantiate"
      pattern: "import.*StateManager"
---

<objective>
StateManager and SocketManager classes implementing data persistence and GM→player broadcast.

Purpose: Complete the data layer infrastructure. After this plan, Phase 2 can build UI that reads/writes speaker state.
Output: scripts/state-manager.mjs, scripts/socket-manager.mjs, updated storyframe.mjs
</objective>

<execution_context>
@/Users/roihorowitz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roihorowitz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StateManager with flag persistence</name>
  <files>scripts/state-manager.mjs</files>
  <action>
Create scripts/ directory and scripts/state-manager.mjs:

```javascript
const MODULE_ID = 'storyframe';
const FLAG_KEY = 'data';
const SCHEMA_VERSION = 1;

/**
 * Manages speaker state persistence in Scene flags.
 * State structure:
 * {
 *   version: 1,
 *   activeJournal: string|null,  // JournalEntry UUID
 *   activeSpeaker: string|null,  // Speaker ID
 *   speakers: [{
 *     id: string,          // Unique ID (foundry.utils.randomID)
 *     actorUuid: string|null,   // Actor UUID for actor-based speakers
 *     imagePath: string|null,   // Direct image path for custom speakers
 *     label: string        // Display name
 *   }]
 * }
 */
export class StateManager {
  constructor() {
    this.state = null;
  }

  /**
   * Load state from current scene's flags.
   * Creates default state if none exists.
   */
  async load() {
    const scene = game.scenes.current;
    if (!scene) {
      console.warn(`${MODULE_ID} | No current scene, cannot load state`);
      return;
    }

    let data = scene.getFlag(MODULE_ID, FLAG_KEY);

    if (!data) {
      // Initialize default structure
      data = this._createDefaultState();
      await scene.setFlag(MODULE_ID, FLAG_KEY, data);
    }

    // Check version and migrate if needed
    if (data.version !== SCHEMA_VERSION) {
      data = await this._migrate(data);
    }

    this.state = data;
    console.log(`${MODULE_ID} | State loaded`, this.state);
  }

  /**
   * Get current state (synchronous).
   */
  getState() {
    return this.state;
  }

  /**
   * Update speakers list and persist.
   * @param {Array} speakers - New speakers array
   */
  async updateSpeakers(speakers) {
    if (!this.state) return;

    const scene = game.scenes.current;
    if (!scene) return;

    this.state.speakers = speakers;
    await scene.setFlag(MODULE_ID, FLAG_KEY, this.state);
    this._broadcast();
  }

  /**
   * Set active speaker and persist.
   * @param {string|null} speakerId - Speaker ID or null for narration
   */
  async setActiveSpeaker(speakerId) {
    if (!this.state) return;

    const scene = game.scenes.current;
    if (!scene) return;

    this.state.activeSpeaker = speakerId;
    await scene.setFlag(MODULE_ID, FLAG_KEY, this.state);
    this._broadcast();
  }

  /**
   * Set active journal and persist.
   * @param {string|null} journalUuid - JournalEntry UUID or null
   */
  async setActiveJournal(journalUuid) {
    if (!this.state) return;

    const scene = game.scenes.current;
    if (!scene) return;

    this.state.activeJournal = journalUuid;
    await scene.setFlag(MODULE_ID, FLAG_KEY, this.state);
    this._broadcast();
  }

  /**
   * Add a speaker to the list.
   * @param {Object} speaker - Speaker data (actorUuid or imagePath, label)
   * @returns {Object} Created speaker with ID
   */
  async addSpeaker({ actorUuid = null, imagePath = null, label }) {
    if (!this.state) return null;

    const speaker = {
      id: foundry.utils.randomID(),
      actorUuid,
      imagePath,
      label
    };

    this.state.speakers.push(speaker);
    await this.updateSpeakers(this.state.speakers);
    return speaker;
  }

  /**
   * Remove a speaker from the list.
   * @param {string} speakerId - Speaker ID to remove
   */
  async removeSpeaker(speakerId) {
    if (!this.state) return;

    this.state.speakers = this.state.speakers.filter(s => s.id !== speakerId);

    // Clear active speaker if removed
    if (this.state.activeSpeaker === speakerId) {
      this.state.activeSpeaker = null;
    }

    await this.updateSpeakers(this.state.speakers);
  }

  /**
   * Resolve speaker to displayable data.
   * Handles deleted actors gracefully.
   * @param {Object} speaker - Speaker object
   * @returns {Object} { img, name }
   */
  async resolveSpeaker(speaker) {
    let img, name;

    if (speaker.actorUuid) {
      const actor = await fromUuid(speaker.actorUuid);
      if (actor) {
        img = actor.img;
        name = actor.name;
      } else {
        // Actor deleted - use fallback
        img = speaker.imagePath || 'icons/svg/mystery-man.svg';
        name = speaker.label || 'Unknown';
      }
    } else {
      // Custom image path
      img = speaker.imagePath || 'icons/svg/mystery-man.svg';
      name = speaker.label;
    }

    return { img, name };
  }

  /**
   * Create default empty state.
   */
  _createDefaultState() {
    return {
      version: SCHEMA_VERSION,
      activeJournal: null,
      activeSpeaker: null,
      speakers: []
    };
  }

  /**
   * Migrate old state to current version.
   * @param {Object} oldData - Old state data
   * @returns {Object} Migrated state
   */
  async _migrate(oldData) {
    console.log(`${MODULE_ID} | Migrating state from v${oldData.version} to v${SCHEMA_VERSION}`);

    // Add migration logic here when schema changes
    // For now, just update version
    oldData.version = SCHEMA_VERSION;

    const scene = game.scenes.current;
    if (scene) {
      await scene.setFlag(MODULE_ID, FLAG_KEY, oldData);
    }

    return oldData;
  }

  /**
   * Notify UI components of state change.
   */
  _broadcast() {
    // ApplicationV2 instances render() when state changes
    game.storyframe.gmApp?.render();
    game.storyframe.playerApp?.render();

    // Also broadcast via socket for other clients
    if (game.storyframe.socketManager) {
      game.storyframe.socketManager.broadcastStateUpdate();
    }
  }
}
```

AVOID:
- Direct flag mutation without setFlag() (Pitfall 6)
- Missing version field (Pitfall 3)
- System-specific APIs like actor.system.* (Pitfall 8)
- Not handling deleted actors (Pitfall 5)
  </action>
  <verify>
- File exists: `ls scripts/state-manager.mjs`
- Exports StateManager: `grep -q "export class StateManager" scripts/state-manager.mjs`
- Has version field: `grep -q "version.*SCHEMA_VERSION\|version.*1" scripts/state-manager.mjs`
- Uses setFlag: `grep -q "setFlag" scripts/state-manager.mjs`
- Handles deleted actor: `grep -q "fromUuid" scripts/state-manager.mjs`
  </verify>
  <done>
- StateManager class exported
- State schema includes version (DATA-02)
- State includes activeJournal, activeSpeaker, speakers (DATA-03)
- Speakers store actorUuid or imagePath (DATA-06)
- Speakers include label field (DATA-07)
- Deleted actor handling with fallback (Pitfall 5)
- Uses setFlag for all mutations (Pitfall 6)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SocketManager with socketlib integration</name>
  <files>scripts/socket-manager.mjs, storyframe.mjs</files>
  <action>
Create scripts/socket-manager.mjs:

```javascript
const MODULE_ID = 'storyframe';

/**
 * Manages socket communication using socketlib.
 * All state mutations route through GM via executeAsGM.
 */
export class SocketManager {
  constructor() {
    this.socket = socketlib.registerModule(MODULE_ID);

    // Register handlers (runs on all clients)
    this.socket.register('updateSpeakers', this._handleUpdateSpeakers);
    this.socket.register('setActiveSpeaker', this._handleSetActiveSpeaker);
    this.socket.register('setActiveJournal', this._handleSetActiveJournal);
    this.socket.register('addSpeaker', this._handleAddSpeaker);
    this.socket.register('removeSpeaker', this._handleRemoveSpeaker);
    this.socket.register('stateUpdate', this._handleStateUpdate);

    console.log(`${MODULE_ID} | SocketManager initialized`);
  }

  // --- Public API (call from any client) ---

  /**
   * Request GM to update speakers list.
   * @param {Array} speakers
   */
  async requestUpdateSpeakers(speakers) {
    return await this.socket.executeAsGM('updateSpeakers', speakers);
  }

  /**
   * Request GM to set active speaker.
   * @param {string|null} speakerId
   */
  async requestSetActiveSpeaker(speakerId) {
    return await this.socket.executeAsGM('setActiveSpeaker', speakerId);
  }

  /**
   * Request GM to set active journal.
   * @param {string|null} journalUuid
   */
  async requestSetActiveJournal(journalUuid) {
    return await this.socket.executeAsGM('setActiveJournal', journalUuid);
  }

  /**
   * Request GM to add a speaker.
   * @param {Object} speakerData - { actorUuid?, imagePath?, label }
   */
  async requestAddSpeaker(speakerData) {
    return await this.socket.executeAsGM('addSpeaker', speakerData);
  }

  /**
   * Request GM to remove a speaker.
   * @param {string} speakerId
   */
  async requestRemoveSpeaker(speakerId) {
    return await this.socket.executeAsGM('removeSpeaker', speakerId);
  }

  /**
   * Broadcast state update to all clients.
   * Called by StateManager after local changes.
   */
  broadcastStateUpdate() {
    const state = game.storyframe.stateManager?.getState();
    if (state) {
      this.socket.executeForEveryone('stateUpdate', state);
    }
  }

  // --- Handlers (execute on GM client) ---

  /**
   * Handler: Update speakers list.
   * Runs on GM client only (socketlib enforces this).
   */
  async _handleUpdateSpeakers(speakers) {
    console.log(`${MODULE_ID} | Socket: updateSpeakers`);
    await game.storyframe.stateManager?.updateSpeakers(speakers);
  }

  /**
   * Handler: Set active speaker.
   */
  async _handleSetActiveSpeaker(speakerId) {
    console.log(`${MODULE_ID} | Socket: setActiveSpeaker`, speakerId);
    await game.storyframe.stateManager?.setActiveSpeaker(speakerId);
  }

  /**
   * Handler: Set active journal.
   */
  async _handleSetActiveJournal(journalUuid) {
    console.log(`${MODULE_ID} | Socket: setActiveJournal`, journalUuid);
    await game.storyframe.stateManager?.setActiveJournal(journalUuid);
  }

  /**
   * Handler: Add speaker.
   */
  async _handleAddSpeaker(speakerData) {
    console.log(`${MODULE_ID} | Socket: addSpeaker`, speakerData);
    return await game.storyframe.stateManager?.addSpeaker(speakerData);
  }

  /**
   * Handler: Remove speaker.
   */
  async _handleRemoveSpeaker(speakerId) {
    console.log(`${MODULE_ID} | Socket: removeSpeaker`, speakerId);
    await game.storyframe.stateManager?.removeSpeaker(speakerId);
  }

  /**
   * Handler: State update broadcast.
   * Runs on all clients to sync state.
   */
  _handleStateUpdate(state) {
    console.log(`${MODULE_ID} | Socket: stateUpdate received`);
    if (game.storyframe.stateManager) {
      game.storyframe.stateManager.state = state;
      // Trigger UI re-render
      game.storyframe.gmApp?.render();
      game.storyframe.playerApp?.render();
    }
  }
}
```

Update storyframe.mjs to import and initialize managers:

1. Add imports at top:
```javascript
import { StateManager } from './scripts/state-manager.mjs';
import { SocketManager } from './scripts/socket-manager.mjs';
```

2. Update setup hook:
```javascript
Hooks.once('setup', () => {
  console.log(`${MODULE_ID} | Setup`);
  game.storyframe.stateManager = new StateManager();
});
```

3. Update socketlib.ready hook:
```javascript
Hooks.once('socketlib.ready', () => {
  console.log(`${MODULE_ID} | Registering sockets`);
  game.storyframe.socketManager = new SocketManager();
});
```

4. Update ready hook to load state:
```javascript
Hooks.once('ready', async () => {
  console.log(`${MODULE_ID} | Ready`);
  await game.storyframe.stateManager.load();
});
```

AVOID:
- Raw socket.emit (Pitfall 4) - use socketlib exclusively
- Custom permission checks - socketlib handles via executeAsGM
  </action>
  <verify>
- SocketManager exists: `ls scripts/socket-manager.mjs`
- Exports SocketManager: `grep -q "export class SocketManager" scripts/socket-manager.mjs`
- Uses socketlib: `grep -q "socketlib.registerModule" scripts/socket-manager.mjs`
- Uses executeAsGM: `grep -q "executeAsGM" scripts/socket-manager.mjs`
- storyframe.mjs imports both: `grep -q "StateManager" storyframe.mjs && grep -q "SocketManager" storyframe.mjs`
  </verify>
  <done>
- SocketManager class exported
- Uses socketlib.registerModule (DATA-04 namespace)
- All mutations use executeAsGM (DATA-05 permission validation)
- State changes broadcast to all clients
- storyframe.mjs initializes both managers in correct hooks
- No raw socket.emit (Pitfall 4)
  </done>
</task>

</tasks>

<verification>
Overall plan verification:

1. Module loads with StateManager and SocketManager initialized
2. State persists to Scene flags (check with Scene.getFlag in console)
3. Socket handlers registered (visible in socketlib debug)
4. State changes broadcast to other clients (test with GM + player browser)
5. Console shows hook sequence: init → setup → socketlib.ready → ready
</verification>

<success_criteria>
Requirements satisfied:
- DATA-01: Speaker data persists in document flags (Scene flags)
- DATA-02: Flag schema includes version number (version: 1)
- DATA-03: State includes activeJournal, activeSpeaker, speakers
- DATA-04: Socket uses module.storyframe namespace
- DATA-05: Socket handlers validate GM permissions (socketlib executeAsGM)
- DATA-06: Speakers store actorUuid or imagePath
- DATA-07: Speaker data includes label field

Pitfalls prevented:
- Pitfall 3: Version field in flag schema
- Pitfall 4: socketlib, not raw sockets
- Pitfall 5: Deleted actor handling with fallback
- Pitfall 6: Uses setFlag for all mutations
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
