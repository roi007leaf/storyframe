---
phase: 03-player-viewer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/applications/player-viewer.mjs
  - templates/player-viewer.hbs
  - styles/player-viewer.css
  - storyframe.mjs
  - module.json
autonomous: true

must_haves:
  truths:
    - "Player can open viewer window"
    - "Viewer shows ALL speakers in gallery (not just active)"
    - "Active speaker is visually highlighted in gallery"
    - "Viewer updates in real-time when GM changes speaker"
    - "Gallery remains visible during narration (no active highlight)"
    - "Player can toggle between grid/list/horizontal layouts"
    - "Layout preference persists per player"
    - "Viewer is read-only (no edit controls)"
    - "Deleted actors show fallback icon"
  artifacts:
    - path: "scripts/applications/player-viewer.mjs"
      provides: "PlayerViewerApp with gallery display and layout toggle"
      contains: "class PlayerViewerApp"
    - path: "templates/player-viewer.hbs"
      provides: "Gallery template with all speakers"
      contains: "{{#each speakers}}"
    - path: "styles/player-viewer.css"
      provides: "3 layout modes (grid/list/horizontal)"
      contains: ".layout-grid"
  key_links:
    - from: "storyframe.mjs"
      to: "PlayerViewerApp"
      via: "import and initialization"
      pattern: "import.*PlayerViewerApp"
    - from: "storyframe.mjs"
      to: "updateScene hook"
      via: "Hooks.on('updateScene')"
      pattern: "Hooks\\.on\\('updateScene'"
    - from: "player-viewer.mjs"
      to: "StateManager"
      via: "_prepareContext uses getState()"
      pattern: "game\\.storyframe\\.stateManager\\.getState"
    - from: "player-viewer.mjs"
      to: "layout setting"
      via: "game.settings.get/set"
      pattern: "game\\.settings\\.(get|set).*playerViewerLayout"
---

<objective>
Create PlayerViewerApp showing ALL speakers in a gallery with the active speaker highlighted. Supports 3 layout modes (grid/list/horizontal) with player-controlled toggle and persistent preference.

Purpose: Complete GM-to-player broadcast loop with gallery view - players see the full conversation cast, not just who's currently speaking.
Output: Working player viewer with gallery display, layout toggle, auto-open behavior, and real-time updates.
</objective>

<execution_context>
@/Users/roihorowitz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/roihorowitz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-player-viewer/03-RESEARCH.md
@.planning/phases/03-player-viewer/03-CONTEXT.md
@scripts/applications/gm-interface.mjs
@styles/gm-interface.css
@storyframe.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlayerViewerApp with gallery template and 3-layout CSS</name>
  <files>
    scripts/applications/player-viewer.mjs
    templates/player-viewer.hbs
    styles/player-viewer.css
  </files>
  <action>
Create PlayerViewerApp extending HandlebarsApplicationMixin(ApplicationV2) with gallery display showing ALL speakers.

**player-viewer.mjs:**
- DEFAULT_OPTIONS: id 'storyframe-player-viewer', classes ['storyframe', 'player-viewer'], window title 'StoryFrame', resizable true, minimizable true, icon 'fas fa-book-open' (same as GM for branding), position width 400 height 300 (adapts to layout)
- PARTS: single 'content' template at 'modules/storyframe/templates/player-viewer.hbs'
- _prepareContext:
  1. Get state from stateManager
  2. Get layout from setting: `game.settings.get('storyframe', 'playerViewerLayout')` (default 'grid')
  3. If no speakers array or empty: return `{ empty: true, layout }`
  4. Resolve ALL speakers via _resolveSpeakers (not just active)
  5. Mark which speaker is active (activeSpeaker matches speaker.id)
  6. Return `{ speakers: resolvedSpeakers, activeSpeakerId: state.activeSpeaker, layout, empty: false }`
- _resolveSpeakers(speakers): async, maps over speakers array, for each calls _resolveSpeaker, returns array
- _resolveSpeaker(speaker): same deleted actor fallback logic (fromUuid, mystery-man.svg)
- Add header action button for layout toggle:
  ```javascript
  static HEADER_ACTIONS = {
    toggleLayout: {
      icon: 'fas fa-th',
      label: 'Toggle Layout',
      onclick: () => this._onToggleLayout()
    }
  };
  ```
- _onToggleLayout(): Cycle through 'grid' -> 'list' -> 'horizontal' -> 'grid', save to setting, re-render

**player-viewer.hbs:**
```handlebars
<div class="speaker-gallery layout-{{layout}}">
  {{#if empty}}
    <div class="empty-state">
      <p>No speakers yet</p>
      <p class="hint">Waiting for GM to add speakers...</p>
    </div>
  {{else}}
    {{#each speakers}}
      <div class="speaker-item {{#if (eq this.id ../activeSpeakerId)}}active{{/if}}">
        <img src="{{this.img}}" alt="{{this.name}}">
        <span class="speaker-name">{{this.name}}</span>
      </div>
    {{/each}}
  {{/if}}
</div>
```

**player-viewer.css:**
Three layout modes sharing common speaker-item styles:

```css
/* Base gallery container */
.storyframe.player-viewer .speaker-gallery {
  padding: 0.75rem;
  height: 100%;
  overflow: auto;
}

/* Grid layout (default) */
.storyframe.player-viewer .speaker-gallery.layout-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 0.5rem;
  align-content: start;
}

/* Vertical list layout */
.storyframe.player-viewer .speaker-gallery.layout-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.storyframe.player-viewer .speaker-gallery.layout-list .speaker-item {
  flex-direction: row;
  padding: 0.5rem;
}

.storyframe.player-viewer .speaker-gallery.layout-list .speaker-item img {
  width: 50px;
  height: 50px;
  margin-right: 0.75rem;
}

/* Horizontal row layout */
.storyframe.player-viewer .speaker-gallery.layout-horizontal {
  display: flex;
  flex-direction: row;
  gap: 0.5rem;
  overflow-x: auto;
  overflow-y: hidden;
  align-items: flex-start;
}

/* Speaker item base */
.storyframe.player-viewer .speaker-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0.25rem;
  border: 2px solid transparent;
  border-radius: 4px;
  transition: all 0.2s;
}

.storyframe.player-viewer .speaker-item img {
  width: 100%;
  aspect-ratio: 1;
  object-fit: cover;
  border-radius: 4px;
}

.storyframe.player-viewer .speaker-name {
  font-size: 0.75rem;
  margin-top: 0.25rem;
  text-align: center;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 100%;
}

/* Active speaker highlight - border + shadow (matches GM interface) */
.storyframe.player-viewer .speaker-item.active {
  border-color: var(--color-text-hyperlink);
  box-shadow: 0 0 8px var(--color-shadow-highlight);
}

/* Empty state */
.storyframe.player-viewer .empty-state {
  text-align: center;
  color: var(--color-text-dark-secondary);
  padding: 2rem 1rem;
}

.storyframe.player-viewer .empty-state .hint {
  font-size: 0.875rem;
  margin-top: 0.5rem;
}
```

Follow active highlight style from GM interface (.speaker-thumbnail.active in gm-interface.css). Use eq helper for Handlebars comparison (already registered in Foundry v13).
  </action>
  <verify>
1. Files exist at correct paths
2. Class extends HandlebarsApplicationMixin(ApplicationV2)
3. _prepareContext returns speakers array with id field for each
4. Template has #each speakers loop
5. CSS has .layout-grid, .layout-list, .layout-horizontal selectors
6. Active highlight uses same border-color as GM interface
  </verify>
  <done>
PlayerViewerApp class with gallery template and 3 layout modes ready for integration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire hooks, settings, and player button</name>
  <files>
    storyframe.mjs
    module.json
  </files>
  <action>
**storyframe.mjs changes:**

1. Add import: `import { PlayerViewerApp } from './scripts/applications/player-viewer.mjs';`

2. Register TWO client settings in init hook:
```javascript
// Layout preference (grid/list/horizontal)
game.settings.register(MODULE_ID, 'playerViewerLayout', {
  scope: 'client',
  config: false,
  type: String,
  default: 'grid',
  choices: {
    grid: 'Grid',
    list: 'List',
    horizontal: 'Horizontal'
  }
});

// Window position persistence
game.settings.register(MODULE_ID, 'playerViewerPosition', {
  scope: 'client',
  config: false,
  type: Object,
  default: {}
});
```

3. In ready hook, after existing GM check, add player initialization:
```javascript
if (!game.user.isGM) {
  game.storyframe.playerViewer = new PlayerViewerApp();

  // Auto-open if there are speakers (gallery shows all, not just active)
  const state = game.storyframe.stateManager.getState();
  if (state?.speakers?.length > 0) {
    game.storyframe.playerViewer.render(true);
  }
}
```

4. Add updateScene hook listener (new hook, outside ready):
```javascript
Hooks.on('updateScene', async (scene, changed, options, userId) => {
  // Only current scene
  if (scene.id !== game.scenes.current?.id) return;
  // Only storyframe flags
  if (!changed.flags?.storyframe) return;

  console.log(`${MODULE_ID} | Scene flags updated`);

  // Reload state
  await game.storyframe.stateManager.load();
  const state = game.storyframe.stateManager.getState();

  // Update GM interface if open
  if (game.user.isGM && game.storyframe.gmApp?.rendered) {
    game.storyframe.gmApp.render();
  }

  // Update player viewer
  if (!game.user.isGM) {
    const viewer = game.storyframe.playerViewer;
    const hasSpeakers = state?.speakers?.length > 0;

    if (hasSpeakers && !viewer.rendered) {
      viewer.render(true);  // Auto-open when first speaker added
    } else if (!hasSpeakers && viewer.rendered) {
      viewer.close();  // Close only if NO speakers (not just no active speaker)
    } else if (viewer.rendered) {
      viewer.render();  // Update display
    }
  }
});
```

Key difference from old plan: Gallery stays open during narration (activeSpeaker null). Only closes when speakers array is empty.

5. In getSceneControlButtons hook, add player button:
After the GM-only block, add:
```javascript
// Player button (non-GM only)
if (!game.user.isGM && controls.tokens) {
  controls.tokens.tools.storyframe = {
    name: 'storyframe',
    title: 'StoryFrame Viewer',
    icon: 'fas fa-book-open',  // Same icon as GM for branding
    visible: true,
    onClick: () => {
      if (!game.storyframe?.playerViewer) {
        game.storyframe.playerViewer = new PlayerViewerApp();
      }
      game.storyframe.playerViewer.render(true);
    },
    button: true
  };
}
```

**module.json:**
Add 'styles/player-viewer.css' to the styles array.

Follow Pattern 2, Pattern 3 from 03-RESEARCH.md. Key behaviors:
- Auto-open when speakers array becomes non-empty (first speaker added)
- Auto-close only when speakers array becomes empty (all removed)
- Stay open during narration (activeSpeaker null, gallery still shows speakers)
- Filter updateScene to current scene only
  </action>
  <verify>
1. Foundry loads without errors
2. Player sees StoryFrame button in token controls (fas fa-book-open icon)
3. GM adding speaker triggers updateScene hook (check console)
4. Player viewer auto-opens when first speaker added
5. Player viewer stays open when activeSpeaker cleared (narration)
6. Player viewer closes when all speakers removed
7. Layout toggle cycles through grid/list/horizontal
  </verify>
  <done>
Player viewer fully integrated with gallery display, layout toggle, and real-time updates.
  </done>
</task>

</tasks>

<verification>
1. As GM: Open GM interface, add speakers to gallery
2. As Player (second browser/incognito): Viewer auto-opens showing ALL speakers in grid layout
3. As GM: Set active speaker -> Player sees highlight on that speaker
4. As GM: Change active speaker -> Highlight moves immediately
5. As GM: Clear speaker (narration) -> Gallery stays visible, no highlight
6. As Player: Click layout toggle button -> Cycles grid/list/horizontal
7. As Player: Close and reopen viewer -> Layout preference persisted
8. As GM: Remove all speakers -> Player viewer closes
9. As GM: Delete actor that's a speaker -> Player viewer shows mystery-man fallback
10. Verify no edit controls visible in player viewer (read-only)
</verification>

<success_criteria>
- PLAY-01: Player can open viewer window via button in token controls
- PLAY-02: Viewer shows ALL speakers (gallery, not single speaker)
- PLAY-03: Viewer shows speaker names (below thumbnails)
- PLAY-04: Viewer updates in real-time via updateScene hook
- PLAY-05: Viewer is read-only (template has no form inputs or buttons except layout toggle)
- PLAY-06: Viewer stays visible during narration (only closes when speakers empty)
- PLAY-07: Deleted actors fall back to mystery-man.svg
- Active speaker has visual highlight (border + shadow)
- Layout toggle works (grid/list/horizontal)
- Layout preference persists per player (client setting)
</success_criteria>

<output>
After completion, create `.planning/phases/03-player-viewer/03-01-SUMMARY.md`
</output>
